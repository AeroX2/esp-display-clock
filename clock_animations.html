<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>128x64 Clock Animation Emulator</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .display {
            width: 512px;
            height: 256px;
            background: #000;
            border: 3px solid #333;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            image-rendering: pixelated;
        }
        canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        button:hover {
            background: #3a3a3a;
        }
        button.active {
            background: #4a90e2;
            border-color: #6bb6ff;
        }
        .info {
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }
        .time-display {
            font-size: 18px;
            color: #4a90e2;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>128x64 Clock Animation Emulator</h1>
    <div class="time-display" id="timeDisplay"></div>
    <div class="display">
        <canvas id="canvas" width="128" height="64"></canvas>
    </div>
    <div class="controls">
        <button id="plasma" class="active">Plasma Field</button>
        <button id="particles">Particle Flow</button>
        <button id="fire">Fire Effect</button>
        <button id="skyline">Parallax Skyline</button>
        <button id="galaxy">Galaxy Spiral</button>
        <button id="lightning">Lightning</button>
        <button id="pipes">3D Pipes</button>
        <button id="orbital">Orbital</button>
        <button id="stars">Stars</button>
        <button id="beach">Beach Scene</button>
    </div>
    <select id="colorDepthSelect">
        <option value="8" selected>Full (8-bit)</option>
        <option value="6">6-bit</option>
        <option value="4">4-bit</option>
        <option value="2">2-bit</option>
        <option value="1">1-bit</option>
    </select>
    <div class="info">
        <p>This emulator shows how different background animations would look on your 128x64 display.</p>
        <p>The canvas is scaled up 4x for better visibility. Each animation creates colorful, dynamic backgrounds perfect for a clock display.</p>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const timeDisplay = document.getElementById('timeDisplay');
        let currentAnimation = 'beach';
        let animationFrame = 0;
        let isRunning = true;
        
        let colorDepth = 8; // Default 8-bit
        document.getElementById('colorDepthSelect').addEventListener('change', (e) => {
            colorDepth = parseInt(e.target.value);
        });

        function quantizeColor(r, g, b) {
            const levels = (1 << colorDepth) - 1;
            const quantize = (v) => Math.round(v / 255 * levels) * (255 / levels);
            return [
                quantize(r),
                quantize(g),
                quantize(b)
            ];
        }

        function quantizeCanvas() {
            const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = img.data;
            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b] = quantizeColor(data[i], data[i + 1], data[i + 2]);
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            ctx.putImageData(img, 0, 0);
        }
        
        function hslToRgb(h, s, l) {
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
            else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
            else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
            else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
            else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        const animations = {
            plasma: () => {
                const imageData = ctx.createImageData(128, 64);
                const data = imageData.data;
                const time = animationFrame * 0.03;
                for (let y = 0; y < 64; y++) {
                    for (let x = 0; x < 128; x++) {
                        const i = (y * 128 + x) * 4;
                        const v1 = Math.sin(x * 0.08 + time);
                        const v2 = Math.sin(y * 0.08 + time * 1.2);
                        const v3 = Math.sin((x + y) * 0.04 + time * 0.8);
                        const plasma = (v1 + v2 + v3) / 3;
                        const hue = 280 + plasma * 80;
                        const saturation = 0.7 + plasma * 0.3;
                        const lightness = 0.4 + plasma * 0.3;
                        const [r, g, b] = hslToRgb(hue % 360, saturation, lightness);
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                        data[i + 3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            },
            
            particles: () => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.fillRect(0, 0, 128, 64);
                for (let i = 0; i < 15; i++) {
                    const x = (animationFrame * 0.3 * (1 + i * 0.1) + i * 25) % 140 - 6;
                    const y = 32 + Math.sin(animationFrame * 0.02 + i) * 25;
                    const hue = (animationFrame * 0.8 + i * 40) % 360;
                    const [r, g, b] = hslToRgb(hue, 0.9, 0.6);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    const trailX = x - 8;
                    if (trailX > 0) {
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                        ctx.beginPath();
                        ctx.arc(trailX, y, 1.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            },
            
            fire: () => {
                const imageData = ctx.createImageData(128, 64);
                const data = imageData.data;
                for (let y = 0; y < 64; y++) {
                    for (let x = 0; x < 128; x++) {
                        const i = (y * 128 + x) * 4;
                        const noise = Math.sin(x * 0.08 + animationFrame * 0.04) * Math.cos(y * 0.12 + animationFrame * 0.03);
                        const flame = Math.max(0, (y + noise * 8) / 64);
                        if (flame > 0.1) {
                            const r = Math.min(255, flame * 240);
                            const g = Math.min(200, Math.max(0, (flame - 0.3) * 350));
                            const b = Math.max(0, (flame - 0.7) * 600);
                            data[i] = r;
                            data[i + 1] = g;
                            data[i + 2] = b;
                            data[i + 3] = 255;
                        } else {
                            data[i] = data[i + 1] = data[i + 2] = 0;
                            data[i + 3] = 255;
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            },
            
            skyline: (() => {
                // Store building state
                const layers = [
                    { // Far background buildings (largest)
                        width: { min: 8, max: 15 },
                        height: { min: 10, max: 42 },
                        speed: 0.02,  // Slowest layer
                        color: 'hsl(200, 12%, 62%)',
                        gap: { min: 3, max: 4 },  // Small gaps for background
                        buildings: []
                    },
                    { // Middle ground
                        width: { min: 12, max: 15 },
                        height: { min: 18, max: 27 },
                        speed: 0.06,  // Medium speed
                        color: 'hsl(200, 13%, 49%)',
                        gap: { min: 8, max: 10 },  // Medium gaps for middle ground
                        buildings: []
                    },
                    { // Foreground
                        width: { min: 16, max: 20 },
                        height: { min: 5, max: 20 },
                        speed: 0.15,  // Fastest layer
                        color: 'hsl(200, 14%, 36%)',
                        gap: { min: 3, max: 5 },  // Larger gaps for foreground
                        buildings: []
                    }
                ];

                // Building class
                class Building {
                    constructor(config) {
                        this.reset(config);
                    }

                    reset(config) {
                        this.layer = config.layer;
                        this.x = config.x;
                        this.y = config.y;
                        this.width = config.width;
                        this.height = config.height;
                        this.color = config.color;
                        this.slantedTop = Math.random() < 0.2;
                        this.slantedTopHeight = this.width / (2 + Math.random() * 2);
                        this.slantedTopDirection = Math.random() < 0.5;
                        this.spireTop = Math.random() < 0.07;
                        this.spireTopWidth = this.width * (0.01 + Math.random() * 0.06);
                        this.spireTopHeight = 3 + Math.random() * 4;
                        this.antennaTop = !this.spireTop && Math.random() < 0.1;
                        this.antennaTopWidth = this.layer / 2;
                        this.antennaTopHeight = 2 + Math.random() * 4;
                    }

                    render(ctx) {
                        // Main building
                        ctx.fillStyle = ctx.strokeStyle = this.color;
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.rect(this.x, this.y, this.width, this.height);
                        ctx.fill();
                        ctx.stroke();

                        // Slanted top
                        if (this.slantedTop) {
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            ctx.lineTo(this.x + this.width, this.y);
                            if (this.slantedTopDirection) {
                                ctx.lineTo(this.x + this.width, this.y - this.slantedTopHeight);
                            } else {
                                ctx.lineTo(this.x, this.y - this.slantedTopHeight);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }

                        // Spire top
                        if (this.spireTop) {
                            ctx.beginPath();
                            ctx.moveTo(this.x + (this.width / 2), this.y - this.spireTopHeight);
                            ctx.lineTo(this.x + (this.width / 2) + this.spireTopWidth, this.y);
                            ctx.lineTo(this.x + (this.width / 2) - this.spireTopWidth, this.y);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }

                        // Antenna top
                        if (this.antennaTop) {
                            ctx.beginPath();
                            ctx.moveTo(this.x + (this.width / 2), this.y - this.antennaTopHeight);
                            ctx.lineTo(this.x + (this.width / 2), this.y);
                            ctx.lineWidth = this.antennaTopWidth;
                            ctx.stroke();
                        }
                    }
                }

                // Initialize buildings for each layer
                layers.forEach(layer => {
                    let totalWidth = 0;
                    while (totalWidth <= 128+20) {
                        const width = Math.round(layer.width.min + Math.random() * (layer.width.max - layer.width.min));
                        const height = Math.round(layer.height.min + Math.random() * (layer.height.max - layer.height.min));
                        
                        // Add layer-specific gap between buildings
                        const gap = Math.floor(layer.gap.min + Math.random() * (layer.gap.max - layer.gap.min));
                        
                        layer.buildings.push(new Building({
                            layer: layer.layer,
                            x: layer.buildings.length === 0 ? 0 : layer.buildings[layer.buildings.length - 1].x + layer.buildings[layer.buildings.length - 1].width + gap,
                            y: 64 - height,
                            width: width,
                            height: height,
                            color: layer.color
                        }));
                        totalWidth += width + gap;
                    }
                });

                return () => {
                    const time = animationFrame * 0.02;
                    
                    // Sky gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, 64);
                    skyGradient.addColorStop(0, '#000033');
                    skyGradient.addColorStop(1, '#000066');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, 128, 64);
                    
                    // Stars
                    for (let i = 0; i < 50; i++) {
                        const x = (i * 13) % 128;
                        const y = (i * 7) % 40;
                        const brightness = Math.sin(time * 0.1 + i) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                        ctx.fillRect(x, y, 1, 1);
                    }

                    // Update and draw each layer
                    layers.forEach(layer => {
                        // Update building positions
                        layer.buildings.forEach(building => {
                            building.x -= layer.speed;
                        });

                        // Recycle buildings
                        const firstBuilding = layer.buildings[0];
                        if (firstBuilding.x + firstBuilding.width < 0) {
                            const lastBuilding = layer.buildings[layer.buildings.length - 1];
                            const width = Math.round(layer.width.min + Math.random() * (layer.width.max - layer.width.min));
                            const height = Math.round(layer.height.min + Math.random() * (layer.height.max - layer.height.min));
                            
                            // Add layer-specific gap for recycled building
                            const gap = Math.floor(layer.gap.min + Math.random() * (layer.gap.max - layer.gap.min));
                            
                            firstBuilding.reset({
                                layer: layer.layer,
                                x: lastBuilding.x + lastBuilding.width + gap,
                                y: 64 - height,
                                width: width,
                                height: height,
                                color: layer.color
                            });
                            
                            layer.buildings.push(layer.buildings.shift());
                        }

                        // Draw buildings
                        layer.buildings.forEach(building => {
                            building.render(ctx);
                        });
                    });
                };
            })(),
            
            galaxy: () => {
                const centerX = 64;
                const centerY = 32;
                const time = animationFrame * 0.01;
                
                // Background with depth
                const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 40);
                bgGradient.addColorStop(0, '#000011');
                bgGradient.addColorStop(1, '#000033');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, 128, 64);
                
                // Spiral arms with multiple layers and perspective
                for (let layer = 0; layer < 4; layer++) {
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        // Stagger the starting angle for each arm
                        const startAngle = (i * Math.PI) + (layer * Math.PI / 4);
                        // Different rotation speeds for each layer
                        const rotationSpeed = 0.8 + layer * 0.2;
                        
                        for (let angle = 0; angle < Math.PI * 4; angle += 0.03) {
                            const depth = 0.8 + layer * 0.2;
                            const radius = angle * 3 * depth;
                            const x = centerX + Math.cos(angle + time * rotationSpeed + startAngle) * radius;
                            const y = centerY + Math.sin(angle + time * rotationSpeed + startAngle) * radius;
                            if (angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        const hue = (layer * 45 + time * 30) % 360;
                        const [r, g, b] = hslToRgb(hue, 1, 0.6);
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            },
            
            lightning: (() => {
                // Store lightning state
                let activeLightnings = [];
                const LIGHTNING_DURATION = 1000; // Longer duration for slow motion
                const PROPAGATION_SPEED = 0.5; // Pixels per frame
                const FADE_DURATION = 200; // Very long fade out duration
                const MAX_LIGHTNINGS = 3; // Maximum number of simultaneous lightning strikes
                const MIN_SPACING = 30; // Minimum horizontal distance between lightning strikes
                
                return () => {
                    const time = animationFrame * 0.001;
                    
                    // Dark stormy background
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, 64);
                    skyGradient.addColorStop(0, '#000022');
                    skyGradient.addColorStop(1, '#000044');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, 128, 64);
                    
                    // Create new lightning if we have room
                    if (activeLightnings.length < MAX_LIGHTNINGS && Math.random() < 0.01) {
                        // Try to find a valid position for new lightning
                        let validPosition = false;
                        let startX = 0;
                        let attempts = 0;
                        const MAX_ATTEMPTS = 10;
                        
                        while (!validPosition && attempts < MAX_ATTEMPTS) {
                            startX = Math.random() * 128;
                            validPosition = true;
                            
                            // Check distance from existing lightning
                            for (const lightning of activeLightnings) {
                                const existingX = lightning.branches[0].x;
                                if (Math.abs(startX - existingX) < MIN_SPACING) {
                                    validPosition = false;
                                    break;
                                }
                            }
                            attempts++;
                        }
                        
                        // Only create lightning if we found a valid position
                        if (validPosition) {
                            const startY = 0;
                            const branches = [];
                            const numBranches = Math.floor(Math.random() * 3) + 1;
                            
                            for (let b = 0; b < numBranches; b++) {
                                const branch = [];
                                let bx = startX + (Math.random() - 0.5) * 20;
                                let by = startY;
                                
                                // Generate full path but only show up to current progress
                                while (by < 64) {
                                    bx += (Math.random() - 0.5) * 4;
                                    by += Math.random() * 2;
                                    branch.push({x: bx, y: by});
                                }
                                // Ensure the last point reaches the ground
                                if (branch[branch.length - 1].y < 64) {
                                    branch.push({
                                        x: branch[branch.length - 1].x,
                                        y: 64
                                    });
                                }
                                branches.push(branch);
                            }
                            
                            activeLightnings.push({
                                branches,
                                progress: 0,
                                frame: 0,
                                reachedGround: false
                            });
                        }
                    }
                    
                    // Draw and update all active lightnings
                    for (let i = activeLightnings.length - 1; i >= 0; i--) {
                        const lightning = activeLightnings[i];
                        let fade = 1;
                        
                        if (lightning.reachedGround) {
                            // Very slow fade out after reaching ground
                            fade = 1 - ((lightning.frame - (64 / PROPAGATION_SPEED)) / FADE_DURATION);
                        } else {
                            // Normal fade during propagation
                            fade = 1 - (lightning.frame / LIGHTNING_DURATION);
                        }
                        
                        // Ensure fade doesn't go below 0
                        fade = Math.max(0, fade);
                        
                        lightning.branches.forEach(branch => {
                            // Find points up to current progress
                            const visiblePoints = branch.filter(point => 
                                point.y <= lightning.progress
                            );
                            
                            if (visiblePoints.length > 1) {
                                // Outer glow
                                ctx.beginPath();
                                ctx.moveTo(visiblePoints[0].x, visiblePoints[0].y);
                                visiblePoints.forEach(point => ctx.lineTo(point.x, point.y));
                                ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 * fade})`;
                                ctx.lineWidth = 4;
                                ctx.stroke();
                                
                                // Inner glow
                                ctx.beginPath();
                                ctx.moveTo(visiblePoints[0].x, visiblePoints[0].y);
                                visiblePoints.forEach(point => ctx.lineTo(point.x, point.y));
                                ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 * fade})`;
                                ctx.lineWidth = 2;
                                ctx.stroke();
                                
                                // Core
                                ctx.beginPath();
                                ctx.moveTo(visiblePoints[0].x, visiblePoints[0].y);
                                visiblePoints.forEach(point => ctx.lineTo(point.x, point.y));
                                ctx.strokeStyle = `rgba(255, 255, 255, ${fade})`;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        });
                        
                        // Update progress
                        if (!lightning.reachedGround) {
                            lightning.progress += PROPAGATION_SPEED;
                            if (lightning.progress >= 64) {
                                lightning.reachedGround = true;
                            }
                        }
                        
                        lightning.frame++;
                        
                        // Remove lightning when it's completely faded out
                        if (fade <= 0) {
                            activeLightnings.splice(i, 1);
                        }
                    }
                    
                    // Improved rain with expanding pattern
                    const raindrops = [];
                    for (let i = 0; i < 60; i++) {
                        if (Math.random() < 0.2) {
                            raindrops.push({
                                x: Math.random() * 128,
                                y: Math.random() * 64,
                                speed: 1 + Math.random() * 1.5,
                                length: 2 + Math.random() * 3,
                                angle: Math.random() * 0.2 - 0.1
                            });
                        }
                    }
                    
                    // Update and draw raindrops
                    for (let i = raindrops.length - 1; i >= 0; i--) {
                        const drop = raindrops[i];
                        drop.y += drop.speed;
                        drop.x += drop.angle;
                        
                        if (drop.y > 64) {
                            raindrops.splice(i, 1);
                            continue;
                        }
                        
                        // Draw drop with slight transparency variation
                        const alpha = 0.3 + Math.sin(time + drop.x) * 0.1;
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.fillRect(drop.x, drop.y, 1, drop.length);
                        
                        // Add a subtle trail
                        if (Math.random() < 0.3) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                            ctx.fillRect(drop.x, drop.y - drop.length, 1, drop.length * 0.5);
                        }
                    }
                };
            })(),

            pipes: (() => {
                // Box trail effect
                const boxes = [];
                const NUM_BOXES = 5;
                const trailLength = 200;
                const RESET_INTERVAL = 5000; // Reset every 5000 frames
                let frameCount = 0;

                function resetBox(box) {
                    box.x = 64;
                    box.y = 32;
                    box.direction = Math.floor(Math.random() * 4);
                    box.red = Math.floor(Math.random() * 255);
                    box.green = Math.floor(Math.random() * 255);
                    box.blue = Math.floor(Math.random() * 255);
                    box.trail = [];
                    box.moveCounter = 0;
                    box.lastDirection = box.direction;
                }

                // Initialize boxes
                for (let i = 0; i < NUM_BOXES; i++) {
                    const box = {
                        x: 64,
                        y: 32,
                        direction: Math.floor(Math.random() * 4),
                        red: Math.floor(Math.random() * 255),
                        green: Math.floor(Math.random() * 255),
                        blue: Math.floor(Math.random() * 255),
                        trail: [],
                        moveCounter: 0,
                        lastDirection: 0
                    };
                    box.lastDirection = box.direction;
                    boxes.push(box);
                }

                function getOppositeDirection(dir) {
                    // 0 (up) ↔ 1 (down)
                    // 2 (left) ↔ 3 (right)
                    switch(dir) {
                        case 0: return 1;  // up -> down
                        case 1: return 0;  // down -> up
                        case 2: return 3;  // left -> right
                        case 3: return 2;  // right -> left
                        default: return dir;
                    }
                }

                function getValidDirections(currentDir, lastDir) {
                    // Get all directions except the opposite of current and last direction
                    return [0, 1, 2, 3].filter(d => 
                        d !== getOppositeDirection(currentDir) && 
                        d !== getOppositeDirection(lastDir)
                    );
                }

                function moveBox(box) {
                    // Store current position in trail
                    box.trail.unshift({x: box.x, y: box.y});
                    if (box.trail.length > trailLength) {
                        box.trail.pop();
                    }

                    // Remember previous direction
                    box.lastDirection = box.direction;

                    // Move box
                    switch(box.direction) {
                        case 0: box.y--; break;  // Up
                        case 1: box.y++; break;  // Down
                        case 2: box.x--; break;  // Left
                        case 3: box.x++; break;  // Right
                    }

                    // Keep within bounds and change direction if hitting edge
                    if (box.x <= 1) {
                        box.x = 1;
                        const validDirs = getValidDirections(3, box.lastDirection);
                        box.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                    } else if (box.x >= 126) {
                        box.x = 126;
                        const validDirs = getValidDirections(2, box.lastDirection);
                        box.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                    }
                    
                    if (box.y <= 1) {
                        box.y = 1;
                        const validDirs = getValidDirections(1, box.lastDirection);
                        box.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                    } else if (box.y >= 62) {
                        box.y = 62;
                        const validDirs = getValidDirections(0, box.lastDirection);
                        box.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                    }

                    // Randomly change direction (more likely when not near edges)
                    if (Math.random() < 0.02 && box.x > 10 && box.x < 118 && box.y > 10 && box.y < 54) {
                        const validDirs = getValidDirections(box.direction, box.lastDirection);
                        if (validDirs.length > 0) {
                            box.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                        }
                    }
                }

                return () => {
                    frameCount++;
                    
                    // Reset all boxes periodically
                    if (frameCount >= RESET_INTERVAL) {
                        frameCount = 0;
                        boxes.forEach(resetBox);
                    }

                    // Clear screen
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, 128, 64);

                    // Update and draw each box
                    boxes.forEach(box => {
                        // Draw trail
                        box.trail.forEach((pos, index) => {
                            const alpha = 1 - (index / trailLength);
                            ctx.fillStyle = `rgba(${box.red/2}, ${box.green/2}, ${box.blue/2}, ${alpha})`;
                            ctx.fillRect(pos.x - 1, pos.y - 1, 2, 2);
                        });

                        // Draw main box
                        ctx.fillStyle = `rgb(${box.red}, ${box.green}, ${box.blue})`;
                        ctx.fillRect(box.x, box.y, 2, 2);

                        // Move box every few frames for smoother movement
                        box.moveCounter++;
                        if (box.moveCounter >= 2) {
                            moveBox(box);
                            box.moveCounter = 0;
                        }
                    });
                };
            })(),

            orbital: (() => {
                // Orbital effect
                const particles = [];
                const NUM_PARTICLES = 20;
                const trailLength = 200;
                const RESET_INTERVAL = 5000; // Reset every 5000 frames
                const GRAVITY_POINT = { 
                    x: 64, 
                    y: 32,
                    velocityX: 0.2,
                    velocityY: 0.15
                };
                const GRAVITY_STRENGTH = 0.05;
                const MIN_SPEED = 0.05;
                const MAX_SPEED = 0.2;
                let frameCount = 0;

                function updateGravityPoint() {
                    // Update position
                    GRAVITY_POINT.x += GRAVITY_POINT.velocityX;
                    GRAVITY_POINT.y += GRAVITY_POINT.velocityY;

                    // Bounce off edges
                    if (GRAVITY_POINT.x <= 0 || GRAVITY_POINT.x >= 127) {
                        GRAVITY_POINT.velocityX *= -1;
                        GRAVITY_POINT.x = Math.max(0, Math.min(127, GRAVITY_POINT.x));
                    }
                    if (GRAVITY_POINT.y <= 0 || GRAVITY_POINT.y >= 63) {
                        GRAVITY_POINT.velocityY *= -1;
                        GRAVITY_POINT.y = Math.max(0, Math.min(63, GRAVITY_POINT.y));
                    }

                    // Add slight randomness to velocity occasionally
                    if (Math.random() < 0.02) {
                        GRAVITY_POINT.velocityX += (Math.random() - 0.5) * 0.1;
                        GRAVITY_POINT.velocityY += (Math.random() - 0.5) * 0.1;
                    }

                    // Keep velocity within reasonable bounds
                    const speed = Math.sqrt(GRAVITY_POINT.velocityX * GRAVITY_POINT.velocityX + 
                                         GRAVITY_POINT.velocityY * GRAVITY_POINT.velocityY);
                    const MAX_GRAVITY_SPEED = 0.3;
                    if (speed > MAX_GRAVITY_SPEED) {
                        GRAVITY_POINT.velocityX = (GRAVITY_POINT.velocityX / speed) * MAX_GRAVITY_SPEED;
                        GRAVITY_POINT.velocityY = (GRAVITY_POINT.velocityY / speed) * MAX_GRAVITY_SPEED;
                    }
                }

                function resetParticle(particle) {
                    // Start from random position
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * 40;
                    particle.x = GRAVITY_POINT.x + Math.cos(angle) * distance;
                    particle.y = GRAVITY_POINT.y + Math.sin(angle) * distance;
                    
                    // Initial velocity perpendicular to radius (for orbital motion)
                    const speed = MIN_SPEED + Math.random() * (MAX_SPEED - MIN_SPEED);
                    particle.velocityX = Math.cos(angle + Math.PI/2) * speed;
                    particle.velocityY = Math.sin(angle + Math.PI/2) * speed;
                    
                    particle.red = Math.floor(Math.random() * 255);
                    particle.green = Math.floor(Math.random() * 255);
                    particle.blue = Math.floor(Math.random() * 255);
                    particle.trail = [];
                }

                // Initialize particles
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    const particle = {
                        x: GRAVITY_POINT.x,
                        y: GRAVITY_POINT.y,
                        velocityX: 0,
                        velocityY: 0,
                        red: Math.floor(Math.random() * 255),
                        green: Math.floor(Math.random() * 255),
                        blue: Math.floor(Math.random() * 255),
                        trail: []
                    };
                    resetParticle(particle);
                    particles.push(particle);
                }

                function updateParticle(particle) {
                    // Store current position in trail
                    particle.trail.unshift({x: particle.x, y: particle.y});
                    if (particle.trail.length > trailLength) {
                        particle.trail.pop();
                    }

                    // Calculate distance and direction to gravity point
                    const dx = GRAVITY_POINT.x - particle.x;
                    const dy = GRAVITY_POINT.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Apply gravity force from center point using inverse square law
                    if (distance > 0) {
                        const force = GRAVITY_STRENGTH / (distance * distance);
                        particle.velocityX += (dx / distance) * force;
                        particle.velocityY += (dy / distance) * force;
                    }

                    // Apply gravity from other particles
                    for (const otherParticle of particles) {
                        if (otherParticle !== particle) {
                            const pdx = otherParticle.x - particle.x;
                            const pdy = otherParticle.y - particle.y;
                            const pDistance = Math.sqrt(pdx * pdx + pdy * pdy);
                            
                            // Only apply force if particles are within a certain range
                            if (pDistance > 0 && pDistance < 30) {
                                const pForce = GRAVITY_STRENGTH * 0.5 / (pDistance * pDistance);
                                particle.velocityX += (pdx / pDistance) * pForce;
                                particle.velocityY += (pdy / pDistance) * pForce;
                            }
                        }
                    }

                    // Update position
                    particle.x += particle.velocityX;
                    particle.y += particle.velocityY;

                    // Wrap around screen edges
                    if (particle.x < 0) particle.x = 127;
                    if (particle.x > 127) particle.x = 0;
                    if (particle.y < 0) particle.y = 63;
                    if (particle.y > 63) particle.y = 0;

                    // Add very subtle randomness to velocity
                    if (Math.random() < 0.01) {
                        particle.velocityX += (Math.random() - 0.5) * 0.02;
                        particle.velocityY += (Math.random() - 0.5) * 0.02;
                    }

                    // Limit maximum speed
                    const speed = Math.sqrt(particle.velocityX * particle.velocityX + particle.velocityY * particle.velocityY);
                    if (speed > MAX_SPEED) {
                        particle.velocityX = (particle.velocityX / speed) * MAX_SPEED;
                        particle.velocityY = (particle.velocityY / speed) * MAX_SPEED;
                    }
                }

                return () => {
                    frameCount++;
                    
                    // Update gravity point position
                    updateGravityPoint();
                    
                    // Reset all particles periodically
                    if (frameCount >= RESET_INTERVAL) {
                        frameCount = 0;
                        particles.forEach(resetParticle);
                    }

                    // Clear screen
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, 128, 64);

                    // Update and draw each particle
                    particles.forEach(particle => {
                        // Draw trail
                        particle.trail.forEach((pos, index) => {
                            const alpha = 1 - (index / trailLength);
                            ctx.fillStyle = `rgba(${particle.red/2}, ${particle.green/2}, ${particle.blue/2}, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, 1, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        // Draw main particle
                        ctx.fillStyle = `rgb(${particle.red}, ${particle.green}, ${particle.blue})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 1.5, 0, Math.PI * 2);
                        ctx.fill();

                        // Update particle
                        updateParticle(particle);
                    });

                    // Draw gravity point
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(GRAVITY_POINT.x, GRAVITY_POINT.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                };
            })(),

            stars: (() => {
                const stars = [];
                const NUM_STARS = 50;
                
                // Initialize stars
                for (let i = 0; i < NUM_STARS; i++) {
                    stars.push({
                        x: (i * 17) % 128,
                        y: (i * 11) % 64,
                        size: 1 + Math.random(),
                        brightness: Math.random(),
                        twinkleSpeed: 0.02 + Math.random() * 0.03,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                return () => {
                    const time = animationFrame * 0.01;
                    
                    // Dark blue background
                    ctx.fillStyle = '#000033';
                    ctx.fillRect(0, 0, 128, 64);

                    // Draw and update stars
                    stars.forEach(star => {
                        star.phase += star.twinkleSpeed;
                        const brightness = (Math.sin(star.phase) + 1) / 2;
                        
                        // Draw star glow
                        const gradient = ctx.createRadialGradient(
                            star.x, star.y, 0,
                            star.x, star.y, star.size * 2
                        );
                        gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.8})`);
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size * 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw star core
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                };
            })(),

            beach: (() => {
                return () => {
                    const time = animationFrame * 0.005;
                    
                    // Sky gradient (40% of height = 25.6px)
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, 25.6);
                    skyGradient.addColorStop(0, '#037ccb');  // Deep sky blue
                    skyGradient.addColorStop(1, '#82ccef');  // Light sky blue
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, 128, 25.6);

                    // Dry sand background (35% of height starting at 65% = from 41.6px to bottom)
                    ctx.fillStyle = '#fdf1d7';  // Dry sand color
                    ctx.fillRect(0, 41.6, 128, 64 - 41.6);

                    // Wave animation parameters (matches CSS waveanim keyframes)
                    let waveScale = 1.0;
                    const cyclePosition = (time * 0.1) % 1; // 10s cycle like CSS
                    
                    if (cyclePosition <= 0.35) {
                        // 0% to 35%: scale from 1.0 to 1.3
                        waveScale = 1.0 + (cyclePosition / 0.35) * 0.3;
                    } else if (cyclePosition <= 0.69) {
                        // 35% to 69%: scale from 1.3 back to 1.0
                        waveScale = 1.3 - ((cyclePosition - 0.35) / (0.69 - 0.35)) * 0.3;
                    } else {
                        // 69% to 100%: stay at 1.0
                        waveScale = 1.0;
                    }

                    // Sea parameters (30% height, 200% width, -50% left, top at 40%)
                    const seaHeight = 19.2 * waveScale;  // 30% of 64px scaled
                    const seaWidth = 256;  // 200% of 128px
                    const seaLeft = -64;   // -50% of 128px
                    const seaTop = 25.6;   // 40% of 64px
                    const seaRadius = seaWidth / 2;  // For 50% border radius

                    // Draw curved sea using elliptical arc (matches CSS border-radius: 0 0 50% 50%)
                    ctx.beginPath();
                    // Start from top-left of sea area
                    ctx.moveTo(seaLeft, seaTop);
                    // Line to top-right
                    ctx.lineTo(seaLeft + seaWidth, seaTop);
                    // Elliptical arc for bottom curve (50% border radius)
                    ctx.ellipse(seaLeft + seaWidth/2, seaTop + seaHeight, seaRadius, seaHeight, 0, 0, Math.PI);
                    ctx.closePath();

                    // Sea gradient (matches CSS sea gradient)
                    const seaGradient = ctx.createLinearGradient(0, seaTop, 0, seaTop + seaHeight);
                    seaGradient.addColorStop(0, 'rgba(8,122,193,1)');     // Deep blue
                    seaGradient.addColorStop(0.25, 'rgba(18,156,192,1)'); // Medium blue
                    seaGradient.addColorStop(0.5, 'rgba(42,212,229,1)');  // Light blue
                    seaGradient.addColorStop(0.75, 'rgba(150,233,239,1)'); // Very light blue
                    seaGradient.addColorStop(1, 'rgba(222,236,211,1)');   // Almost white
                    ctx.fillStyle = seaGradient;
                    ctx.fill();

                    // Seafoam animation (matches CSS seafoam keyframes)
                    let seafoamOpacity = 0;
                    if (cyclePosition <= 0.3) {
                        // 0% to 30%: opacity from 0 to 1
                        seafoamOpacity = cyclePosition / 0.3;
                    } else if (cyclePosition <= 0.5) {
                        // 30% to 50%: opacity from 1 to 0
                        seafoamOpacity = 1 - ((cyclePosition - 0.3) / 0.2);
                    } else {
                        // 50% to 100%: opacity stays 0
                        seafoamOpacity = 0;
                    }

                    // if (seafoamOpacity > 0) {
                    //     // Seafoam gradient (transparent to white at bottom)
                    //     const foamGradient = ctx.createLinearGradient(0, seaTop, 0, seaTop + seaHeight);
                    //     foamGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    //     foamGradient.addColorStop(0.9, 'rgba(255, 255, 255, 0)');
                    //     foamGradient.addColorStop(1, `rgba(255, 255, 255, ${seafoamOpacity})`);
                        
                    //     // Apply seafoam to sea area
                    //     ctx.save();
                    //     ctx.globalCompositeOperation = 'source-atop';
                    //     ctx.fillStyle = foamGradient;
                    //     ctx.fillRect(seaLeft, seaTop, seaWidth, seaHeight);
                    //     ctx.restore();
                    // }

                    // Wet sand animation (matches CSS wetsand keyframes)
                    let wetSandOpacity = 0.2;
                    if (cyclePosition >= 0.34 && cyclePosition <= 0.35) {
                        wetSandOpacity = 0.2 + ((cyclePosition - 0.34) / 0.01) * 0.2; // 0.2 to 0.4
                    } else if (cyclePosition > 0.35) {
                        wetSandOpacity = 0.4 - ((cyclePosition - 0.35) / 0.65) * 0.2; // 0.4 back to 0.2
                    }

                    // Wet sand (37.5% height, same positioning as sea but slightly larger)
                    const wetSandHeight = 24;  // 37.5% of 64px
                    ctx.globalAlpha = wetSandOpacity;
                    
                    ctx.beginPath();
                    ctx.moveTo(seaLeft, seaTop);
                    ctx.lineTo(seaLeft + seaWidth, seaTop);
                    ctx.ellipse(seaLeft + seaWidth/2, seaTop + wetSandHeight, seaRadius, wetSandHeight, 0, 0, Math.PI);
                    ctx.closePath();
                    
                    ctx.fillStyle = '#ecc075'; // Wet sand color
                    ctx.fill();
                    ctx.globalAlpha = 1; // Reset alpha

                    // Add some seabirds in the distance (render before tree so they appear beneath)
                    for (let i = 0; i < 1; i++) {
                        const birdX = (time * 10 + i * 40) % 150 - 10;
                        const birdY = 8 + Math.sin(time * 0.5 + i) * 3;
                        
                        // Simple bird shape
                        ctx.strokeStyle = 'rgba(80, 80, 80, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(birdX - 2, birdY);
                        ctx.lineTo(birdX, birdY - 1);
                        ctx.lineTo(birdX + 2, birdY);
                        ctx.moveTo(birdX, birdY - 1);
                        ctx.lineTo(birdX + 1, birdY + 1);
                        ctx.stroke();
                    }

                    // Palm tree (positioned on the right side)
                    const treeX = 120;  // Right side of screen
                    const treeY = 30;  // Middle area
                    
                    // Palm trunk - curved like a banana (matches CSS design)
                    ctx.fillStyle = '#aa8366';  // Brown trunk color
                    ctx.beginPath();
                    
                    // Create curved banana-like trunk using bezier curve
                    const trunkBase = { x: treeX, y: treeY + 20 };
                    const trunkTop = { x: treeX - 8, y: treeY - 32 };
                    const trunkWidth = 6;
                    
                    // Left side of curved trunk
                    ctx.moveTo(trunkBase.x - trunkWidth/2, trunkBase.y);
                    ctx.quadraticCurveTo(
                        trunkBase.x - trunkWidth/2 - 5, treeY + 8, 
                        trunkTop.x - trunkWidth/2, trunkTop.y
                    );
                    
                    // Top curve
                    ctx.quadraticCurveTo(trunkTop.x, trunkTop.y - 2, trunkTop.x + trunkWidth/2, trunkTop.y);
                    
                    // Right side of curved trunk
                    ctx.quadraticCurveTo(
                        trunkBase.x + trunkWidth/2 - 3, treeY + 8, 
                        trunkBase.x + trunkWidth/2, trunkBase.y
                    );
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add some trunk texture lines
                    ctx.strokeStyle = '#8b6f47';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const y = trunkBase.y - 5 - i * 7;
                        const xOffset = -2 - i * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(treeX + xOffset - 2, y);
                        ctx.lineTo(treeX + xOffset + 2, y);
                        ctx.stroke();
                    }

                    // Palm leaves (3 leaves at different angles)
                    const leafColors = ['#394d00', '#465a05', '#465a05'];
                    const leafAngles = [-70, -20, 50];
                    const leafPositions = [
                        {x: trunkTop.x + 16, y: trunkTop.y + 6}, // Right leaf
                        {x: trunkTop.x + 6, y: trunkTop.y + 16}, // Right-angled leaf
                        {x: trunkTop.x - 16, y: trunkTop.y + 12} // Right-angled leaf
                    ];
                    
                    for (let i = 0; i < 3; i++) {
                        ctx.save();
                        ctx.translate(leafPositions[i].x, leafPositions[i].y);
                        ctx.rotate((leafAngles[i] * Math.PI) / 180);
                        
                        // Draw leaf as elongated ellipse
                        ctx.fillStyle = leafColors[i];
                        ctx.beginPath();
                        ctx.ellipse(0, -8, 4, 12, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                };
            })(),
        };

        function animate() {
            if (!isRunning) return;
            animations[currentAnimation]();
            const now = new Date();
            const timeStr = now.getHours().toString().padStart(1, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                'July', 'August', 'September', 'October', 'November', 'December'];
            const dateStr = monthNames[now.getMonth()] + ' ' + now.getDate();
            timeDisplay.textContent = timeStr + ' - ' + dateStr;
            ctx.imageSmoothingEnabled = false;
            ctx.textAlign = 'center';
            ctx.lineWidth = 2;
            ctx.font = 'bold 40px monospace';
            ctx.strokeStyle = 'white';
            ctx.strokeText(timeStr, 64, 35);
            ctx.fillStyle = 'black';
            ctx.fillText(timeStr, 64, 35);
            ctx.font = 'bold 18px monospace';
            ctx.strokeStyle = 'white';
            ctx.strokeText(dateStr, 64, 58);
            ctx.fillStyle = 'black';
            ctx.fillText(dateStr, 64, 58);
            
            // Apply color depth simulation
            if (colorDepth < 8) {
                quantizeCanvas();
            }
            
            animationFrame++;
            requestAnimationFrame(animate);
        }

        document.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.active').classList.remove('active');
                btn.classList.add('active');
                currentAnimation = btn.id;
                animationFrame = 0;
            });
        });

        animate();
    </script>
</body>
</html>
